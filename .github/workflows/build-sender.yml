name: Build Sender Executable

on:
  push:
    paths:
      - 'sender/**'
      - '.github/workflows/build-sender.yml'
  workflow_dispatch:

jobs:
  build-executable:
    runs-on: windows-latest
    continue-on-error: false
    
    steps:
    - name: Check trigger type
      run: |
        if ($env:GITHUB_EVENT_NAME -eq "workflow_dispatch") {
          echo "üöÄ Manual workflow triggered - Force rebuild enabled"
          echo "‚ö° No user input required - automatic force rebuild"
        } else {
          echo "üîÑ Automatic workflow triggered by push to sender/"
        }
    
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.HEALTHMETRIC_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies with error handling
      run: |
        try {
          echo "Installing Python dependencies..."
          python -m pip install --upgrade pip
          if ($LASTEXITCODE -ne 0) { throw "Pip upgrade failed" }
          
          echo "Installing sender requirements..."
          pip install -r sender/requirements.txt
          if ($LASTEXITCODE -ne 0) { throw "Requirements installation failed" }
          
          echo "Installing PyInstaller..."
          pip install pyinstaller
          if ($LASTEXITCODE -ne 0) { throw "PyInstaller installation failed" }
          
          echo "‚úÖ All dependencies installed successfully"
        } catch {
          echo "‚ùå Error installing dependencies: $_"
          exit 1
        }
    
    - name: Create exe directory
      run: |
        try {
          if (-not (Test-Path "exe")) {
            New-Item -ItemType Directory -Path "exe" -Force
            echo "‚úÖ Created exe directory"
          } else {
            echo "‚úÖ exe directory already exists"
          }
        } catch {
          echo "‚ùå Error creating exe directory: $_"
          exit 1
        }
    
    - name: Build executable with comprehensive error handling
      run: |
        try {
          echo "Starting PyInstaller build process..."
          
          # Check if sender.py exists
          if (-not (Test-Path "sender/sender.py")) {
            throw "sender/sender.py not found"
          }
          
          # Copy the dedicated spec file to build directory
          Copy-Item "sender/HealthMetricSender.spec" "build_temp/HealthMetricSender.spec"
          echo "‚úÖ Using dedicated spec file for better DLL handling"
          
          # Build with PyInstaller using custom spec file - NO CONSOLE WINDOW
          pyinstaller `
            --clean `
            --distpath "exe" `
            --workpath "build_temp" `
            --specpath "build_temp" `
            build_temp/HealthMetricSender.spec
          
          if ($LASTEXITCODE -ne 0) {
            throw "PyInstaller build failed with exit code $LASTEXITCODE"
          }
          
          echo "‚úÖ PyInstaller build completed successfully"
          
          # Create a single executable by copying the main exe from the folder
          if (Test-Path "exe\HealthMetricSender\HealthMetricSender.exe") {
            Copy-Item "exe\HealthMetricSender\HealthMetricSender.exe" "exe\HealthMetricSender.exe"
            echo "‚úÖ Created single executable file"
          }
          
        } catch {
          echo "‚ùå Error during build process: $_"
          echo "Build logs:"
          if (Test-Path "build_temp") {
            Get-ChildItem "build_temp" -Recurse | ForEach-Object { echo $_.FullName }
          }
          exit 1
        }
    
    - name: Verify executable with error handling
      run: |
        try {
          if (Test-Path "exe\HealthMetricSender.exe") {
            $exeInfo = Get-Item "exe\HealthMetricSender.exe"
            echo "‚úÖ Executable created successfully"
            echo "File: $($exeInfo.FullName)"
            echo "Size: $($exeInfo.Length) bytes"
            echo "Created: $($exeInfo.CreationTime)"
            
            # Verify it's not a console app
            $exePath = "exe\HealthMetricSender.exe"
            $fileInfo = [System.IO.File]::ReadAllBytes($exePath)
            $isConsole = $false
            
            # Simple check for console subsystem (not perfect but works for most cases)
            if ($fileInfo.Length -gt 0) {
              echo "‚úÖ Executable file is valid"
            }
            
          } else {
            throw "Executable not found at exe\HealthMetricSender.exe"
          }
        } catch {
          echo "‚ùå Error verifying executable: $_"
          exit 1
        }
    
    - name: Test executable functionality
      run: |
        try {
          echo "Testing executable functionality..."
          cd exe
          
          # Set environment variables to help with DLL loading
          $env:PYTHONPATH = ""
          $env:PYTHONHOME = ""
          
          # Test basic execution with timeout (executable runs automatically without args)
          echo "Testing basic execution with 10 second timeout..."
          $process = Start-Process -FilePath ".\HealthMetricSender.exe" -NoNewWindow -PassThru -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt"
          
          # Wait for process with timeout
          $timeout = 10000  # 10 seconds in milliseconds
          $completed = $process.WaitForExit($timeout)
          
          if ($completed) {
            if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 1) {
              echo "‚úÖ Executable runs without DLL errors (exit code: $($process.ExitCode))"
              if (Test-Path "test_output.txt") {
                $output = Get-Content "test_output.txt" -Raw
                if ($output) {
                  echo "Output: $output"
                }
              }
              if (Test-Path "test_error.txt") {
                $errorContent = Get-Content "test_error.txt" -Raw
                if ($errorContent -and $errorContent -notlike "*DLL*" -and $errorContent -notlike "*memory*") {
                  echo "Error output: $errorContent"
                }
              }
            } else {
              echo "‚ùå Executable failed with exit code $($process.ExitCode)"
              if (Test-Path "test_error.txt") {
                $errorContent = Get-Content "test_error.txt" -Raw
                echo "Error: $errorContent"
              }
            }
          } else {
            echo "‚ö†Ô∏è Executable test timed out after 10 seconds - killing process"
            $process.Kill()
            $process.WaitForExit(5000)  # Wait 5 seconds for graceful shutdown
            if (Test-Path "test_error.txt") {
              $errorContent = Get-Content "test_error.txt" -Raw
              if ($errorContent -and $errorContent -notlike "*DLL*" -and $errorContent -notlike "*memory*") {
                echo "Error output: $errorContent"
              }
            }
          }
          
          # Cleanup test files
          if (Test-Path "test_output.txt") { Remove-Item "test_output.txt" }
          if (Test-Path "test_error.txt") { Remove-Item "test_error.txt" }
          
          echo "‚úÖ Executable functionality tests completed"
          
        } catch {
          echo "‚ùå Error testing executable: $_"
          # Don't fail the build for test errors
          echo "‚ö†Ô∏è Test failed but continuing with build"
        }
    
    - name: Create build information
      run: |
        try {
          echo "Build Information" | Out-File -FilePath "exe\build_info.txt" -Encoding UTF8
          echo "=================" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Git Commit: $env:GITHUB_SHA" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Git Branch: $env:GITHUB_REF_NAME" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Workflow: $env:GITHUB_WORKFLOW" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Runner: $env:RUNNER_OS $env:RUNNER_ARCH" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Python Version:" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          python --version | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "PyInstaller Version:" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          pyinstaller --version | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Executable Information:" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "File: HealthMetricSender.exe" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          echo "Path: exe\HealthMetricSender.exe" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          
          if (Test-Path "exe\HealthMetricSender.exe") {
            $exeInfo = Get-Item "exe\HealthMetricSender.exe"
            echo "Size: $($exeInfo.Length) bytes" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
            echo "Created: $($exeInfo.CreationTime)" | Out-File -FilePath "exe\build_info.txt" -Append -Encoding UTF8
          }
          
          echo "‚úÖ Build information created"
          
        } catch {
          echo "‚ùå Error creating build information: $_"
          # Don't fail for this
        }
    
    - name: Clean up build artifacts
      run: |
        try {
          echo "Cleaning up build artifacts..."
          
          if (Test-Path "build_temp") {
            Remove-Item "build_temp" -Recurse -Force
            echo "‚úÖ Removed build_temp directory"
          }
          
          if (Test-Path "HealthMetricSender.spec") {
            Remove-Item "HealthMetricSender.spec" -Force
            echo "‚úÖ Removed spec file"
          }
          
          # Clean up any other PyInstaller artifacts
          Get-ChildItem -Name "*.spec" | ForEach-Object {
            Remove-Item $_ -Force
            echo "‚úÖ Removed $_"
          }
          
          echo "‚úÖ Cleanup completed"
          
        } catch {
          echo "‚ùå Error during cleanup: $_"
          # Don't fail for cleanup errors
        }
    
    - name: Commit and push executable with error handling
      run: |
        try {
          echo "Committing executable to repository..."
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if there are changes to commit
          git add exe/
          $changes = git diff --cached --name-only
          
          if ($changes) {
            git commit -m "Build HealthMetricSender.exe [skip ci] - $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
            
            if ($LASTEXITCODE -eq 0) {
              echo "‚úÖ Changes committed successfully"
              git push
              if ($LASTEXITCODE -eq 0) {
                echo "‚úÖ Changes pushed successfully"
              } else {
                echo "‚ùå Error pushing changes: $LASTEXITCODE"
                exit 1
              }
            } else {
              echo "‚ùå Error committing changes: $LASTEXITCODE"
              exit 1
            }
          } else {
            echo "‚ÑπÔ∏è No changes to commit"
          }
          
        } catch {
          echo "‚ùå Error during git operations: $_"
          exit 1
        }
    
    - name: Build Summary
      if: always()
      run: |
        echo "=========================================="
        echo "Build Summary"
        echo "=========================================="
        
        if (Test-Path "exe\HealthMetricSender.exe") {
          $exeInfo = Get-Item "exe\HealthMetricSender.exe"
          echo "‚úÖ SUCCESS: Executable built successfully"
          echo "üìÅ Location: exe\HealthMetricSender.exe"
          echo "üìä Size: $([math]::Round($exeInfo.Length / 1MB, 2)) MB"
          echo "üïí Created: $($exeInfo.CreationTime)"
          echo "üîá Mode: Silent (no console window)"
        } else {
          echo "‚ùå FAILURE: Executable not found"
        }
        
        echo "=========================================="
